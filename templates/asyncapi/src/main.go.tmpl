// {{ .ModuleName }} – Asynchrone Microservice-Stub generiert von dredger
package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"

	"github.com/nats-io/jetstream.go"
	"github.com/nats-io/nats.go"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"{{ .ModuleName }}/async/cli"
	"{{ .ModuleName }}/async/config"
	"{{ .ModuleName }}/async/handler"
	"{{ .ModuleName }}/async/logger"
	"{{ .ModuleName }}/async/tracing"
	"{{ .ModuleName }}/async/utils"
)

func main() {
	// 1) ENV einlesen
	cfg := config.LoadEnv()

	// 2) Logger initialisieren
	lvl := zerolog.InfoLevel
	if l, err := zerolog.ParseLevel(cfg.LogLevel); err == nil {
		lvl = l
	}
	logger.InitLogger(lvl)

	// 3) Tracing (optional)
	if cfg.TracingEnabled {
		tracer := tracing.InitJaegerTracer("{{ .Title }}")
		defer tracing.ShutdownTracer(tracer)
	}

	// 4) NATS-Verbindung
	opts := []nats.Option{nats.Name("{{ .ModuleName }}")}
	if cfg.NatsUsername != "" && cfg.NatsPassword != "" {
		opts = append(opts,
			nats.UserInfo(cfg.NatsUsername, cfg.NatsPassword),
		)
	}
	nc, err := nats.Connect(cfg.NatsURL, opts...)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to connect to NATS")
	}
	defer nc.Drain()

	// JetStream-Context für Stream-Bindings
	js, _ := jetstream.New(nc)

	// 5) Subscriber einrichten
	// TODO: Hier Subscriber für deine Channels anlegen, z.B.
	// sub, err := nc.Subscribe("subject", handler.HandlerFunc("subject", "./schemas", myHandler))
	// if err != nil {
	//     log.Fatal().Err(err).Msg("Subscribe failed")
	// }
	_ = js

	// 6) CLI-Modus für Tests / Publish
	go func() {
		if err := cli.Run(nc); err != nil {
			log.Error().Err(err).Msg("CLI error")
		}
	}()

	// 7) Graceful Shutdown
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	log.Info().Msg("Shutting down service")
	nc.Close()
}
