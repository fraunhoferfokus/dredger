// Don't edit this file, as it is generated by dredger
package rest

import (
	"fmt"
	"time"

	"github.com/r3labs/sse/v2"

	"{{ lcfirst ( camelcase .ModuleName ) }}/core"
)

// learn medium duration
var durationSum map[string]int = map[string]int{"": core.AppConfig.ProgressDuration} // initial duration in deciseconds
var durationNb map[string]int = map[string]int{"": 1}

// InitialDuration sets the expected duration time in deciseconds
func InitialDuration(context string, duration int) {
	durationSum[context] = duration
	durationNb[context] = 1
}

const picoNull = `<progress value="0" max="100" />`
const picoEndless = `<progress />`
const picoProgress = `<progress value="%d" max="100" />`
const picoEmpty = `<div/>`

func ProgressPico(context string, f func()) {
	duration := durationSum[context] / durationNb[context]
	c1 := make(chan bool)
	go func() {
		f()
		c1 <- true
	}()

	v := 0
	SseServer.Publish("progress", &sse.Event{
		Event: []byte("Progress"),
		Data:  []byte(picoNull),
	})
	for ready := false; !ready; {
		select {
		case <-c1:
			ready = true
		case <-time.After(500 * time.Millisecond):
			v = v + 5
			if v > duration && v <= duration+5 {
				SseServer.Publish("progress", &sse.Event{
					Event: []byte("Progress"),
					Data:  []byte(picoEndless),
				})
			} else if v < duration {
				SseServer.Publish("progress", &sse.Event{
					Event: []byte("Progress"),
					Data:  []byte(fmt.Sprintf(picoProgress, v)),
				})
			}
		}
	}
	SseServer.Publish("progress", &sse.Event{
		Event: []byte("Progress"),
		Data:  []byte(picoEmpty),
	})

	// update medium duration
	durationSum[context] += v
	durationNb[context] += 1
	// avoid overflow of durationNb
	if durationNb[context] > 10000 {
		durationSum[context] = durationSum[context] / durationNb[context]
		durationNb[context] = 1
	}
}

const styleProgress = ` style="--bs-progress-border-radius:0px;--bs-progress-height:15px;"`
const styleProgressBar = `--bs-progress-bar-bg:#005b7f;`

const bsNull = `<div class="progress" role="progressbar" aria-label="Success striped" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"` + styleProgress + `><div class="progress-bar progress-bar-striped" style="width: 0%;` + styleProgressBar + `"></div></div>`
const bsEndless = `<div class="progress" role="progressbar" aria-label="Success striped" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"` + styleProgress + `><div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%%;` + styleProgressBar + `">%s</div></div>`
const bsProgress = `<div class="progress" role="progressbar" aria-label="Success striped" aria-valuenow="%d" aria-valuemin="0" aria-valuemax="100"` + styleProgress + `><div class="progress-bar progress-bar-striped" style="width: %d%%;` + styleProgressBar + `">%s</div></div>`
const bsEmpty = `<div/>`

func ProgressBootstrap(context string, f func(), labels ...string) {
	duration := durationSum[context] / durationNb[context]

	if len(labels) == 0 {
		labels = append(labels, "")
	}
	if len(labels) == 1 {
		labels = append(labels, "")
	}
	msg := labels[0]
	nbOfIntervals := len(labels) - 1

	c1 := make(chan bool)
	go func() {
		f()
		c1 <- true
	}()

	v := 0
	SseServer.Publish("progress", &sse.Event{
		Event: []byte("Progress"),
		Data:  []byte(bsNull),
	})
	for ready := false; !ready; {
		select {
		case <-c1:
			ready = true
		case <-time.After(500 * time.Millisecond):
			v = v + 5
			if v >= duration {
				SseServer.Publish("progress", &sse.Event{
					Event: []byte("Progress"),
					Data:  []byte(fmt.Sprintf(bsEndless, msg)),
				})
			} else {
				label := labels[(v/(duration/nbOfIntervals))+1]
				SseServer.Publish("progress", &sse.Event{
					Event: []byte("Progress"),
					Data:  []byte(fmt.Sprintf(bsProgress, v, v, label)),
				})
			}
		}
	}
	SseServer.Publish("progress", &sse.Event{
		Event: []byte("Progress"),
		Data:  []byte(bsEmpty),
	})

	// update medium duration
	if nb := durationNb[context]; nb > 0 {
		durationSum[context] += v
		durationNb[context] += 1
		// avoid overflow of durationNb
		if durationNb[context] > 10000 {
			durationSum[context] = durationSum[context] / durationNb[context]
			durationNb[context] = 1
		}
	} else {
		log.Error().Str("context", context).Msg("Context doesn't exist, please initialize context")
	}
}
