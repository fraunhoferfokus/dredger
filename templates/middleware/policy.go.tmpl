// Don't edit this file, as it is generated by dredger
package middleware

import (
	"bytes"
	"context"
	_ "embed"
	"encoding/base64"
	"encoding/json"
	"io"
	"net/http"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/open-policy-agent/opa/ast"
	"github.com/open-policy-agent/opa/rego"

	"{{.ModuleName}}/core"
	"{{.ModuleName}}/core/log"
)

var (
	//go:embed authz.rego
	authz string

	policyCompiler *ast.Compiler
)

// Default values
func init() {
	if core.AppConfig.Policy == "" {
		log.Info().Msg("use default policy")
		core.AppConfig.Policy = authz
	}
	if core.AppConfig.Realm == "" {
		core.AppConfig.Realm = core.AppConfig.Service
	}

	// precompile policy
	// log.Debug().Str("policy", core.AppConfig.Policy).Msg("got policy")
	var err error
	policyCompiler, err = ast.CompileModules(map[string]string{
		"authz.rego": core.AppConfig.Policy,
	})
	if err != nil {
		log.Printf("wrong rego policy (%s)\n", err)
	}

}

type Action int

const (
	Allow = iota
	Logout
	Authorize
	Deny
	NotFound
)

type Input map[string]interface{}

func checkAuthorization(authorizationHeader string) (string, bool) {

	parts := strings.Split(authorizationHeader, " ")
	if len(parts) < 2 {
		return "", false
	}
	if strings.ToLower(parts[0]) == "bearer" {
		if len(core.AppConfig.ApiKeys) > 0 {
			token, err := base64.RawStdEncoding.DecodeString(parts[1])
			if err != nil {
				log.Warn().Err(err).Msg("Failed decoding base64 token")
				return "", false
			} else {
				for _, key := range core.AppConfig.ApiKeys {
					if key == string(token) {
						return "api", true
					}
				}
				log.Warn().Msg("Failed matching api token")
				return "", false
			}
		}
		log.Debug().Msg("assign api")
		return "api", true
	}

	if strings.ToLower(parts[0]) != "basic" {
		log.Debug().Msg("No basic authorisation")
		return "", false
	}
	token, err := base64.StdEncoding.DecodeString(parts[1])
	if err != nil {
		log.Debug().Msg("Failed to decode the authorisation token")
		return "", false
	}
	tokenParts := strings.Split(string(token), ":")
	if len(tokenParts) != 2 {
		log.Debug().Msg("Authorisation token to short")
		return "", false
	}
	user := tokenParts[0]
	password := tokenParts[1]
	// Check staff user
	if core.AppConfig.StaffUser != "" && user == core.AppConfig.StaffUser {
		if password == core.AppConfig.StaffPassword {
			log.Debug().Msg("authenticated staff")
			return "staff", true
		} else {
			log.Debug().Msg("rejected staff")
			return "", false
		}
	}
	// If no user is configured, its role is authorized by default
	if core.AppConfig.ParticipantUser == "" {
		log.Debug().Msg("assign user")
		return "user", true
	}
	// Check user
	if user == core.AppConfig.ParticipantUser && password == core.AppConfig.ParticipantPassword {
		log.Debug().Msg("authenticated user")
		return "user", true
	}
	return "", false
}

type OpaResult struct {
	Result bool `json:"result"`
}

func checkPolicyLocal(req *http.Request, rule string, input Input) bool {
	query := rego.New(
		rego.Query("data.{{.ModuleName}}.authz."+rule),
		rego.Compiler(policyCompiler),
		rego.Input(input),
	)
	// Run evaluation
	results, err := query.Eval(context.Background())
	if err != nil {
		log.Warn().Err(err).Any("input", input).Msg("Policy evaluation failed")
		return false
	} else if len(results) == 0 {
		log.Warn().Str("rule", rule).Any("input", input).Msg("Policy evaluation returned undefined result")
		return false
	} else if _, ok := results[0].Expressions[0].Value.(bool); !ok {
		log.Warn().Str("rule", rule).Any("input", input).Msg("Policy evaluation returned wrong result type")
		return false
	} else {
		return results[0].Expressions[0].Value.(bool)
	}
}

func checkPolicyOpaSvc(req *http.Request, rule string, input Input) bool {
	jsonData, err := json.Marshal(input)
	if err != nil {
		log.Error().Err(err).Str("rule", rule).Msg("Could not marshall input for to JSON")
		return false
	}
	buf := bytes.NewReader(jsonData)
	resp, err := http.Post("http://"+core.AppConfig.OpaSvc+"/v1/data/{{.ModuleName}}/authz/"+rule, "application/json", buf)
	if err != nil {
		log.Error().Err(err).Str("rule", rule).Msg("Calling policy check failed")
		return false
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Error().Err(err).Str("rule", rule).Msg("Could not read result from policy check")
		return false
	}
	var result OpaResult
	err = json.Unmarshal(body, &result)
	if err != nil {
		log.Error().Err(err).Str("rule", rule).Str("result", string(body)).Msg("Couldn't unmarshall result from policy check")
		return false
	}
	return result.Result
}

func checkPolicy(c echo.Context) Action {
	req := c.Request()
	// Check first, if it is a logout
	if req.URL.Query().Get("logout") == "true" {
		return Logout
	}

	// extract input from request
	authorization := req.Header.Get(core.AppConfig.AuthorizationHeader)
	role, authorized := checkAuthorization(authorization)
	if !authorized && core.AppConfig.OpaSvc == "" && core.AppConfig.Policy == "" && (core.AppConfig.ParticipantUser != "" || core.AppConfig.StaffUser != "") {
		log.Debug().Str("authorization", authorization).Msg("Authorization failed")
		return Authorize
	}

	return checkAccess(req, role)
}

func checkAccess(req *http.Request, role string) Action {
	input := Input{
		"url":      req.URL.String(),
		"method":   req.Method,
		"path":     req.URL.Path,
		"trace":    req.Header.Get("Tracing"),
		"session":  req.Header.Get("Session-Id"),
		"host":     core.AppConfig.Host,
		"role":     role,
	}

	var ok bool
	// Check if access is valid
	if core.AppConfig.OpaSvc != "" {
		ok = checkPolicyOpaSvc(req, "allowAccess", input)
	} else if core.AppConfig.Policy != "" {
		ok = checkPolicyLocal(req, "allowAccess", input)
	} else {
		ok = true
	}
	if !ok {
		log.Warn().Str("role", role).Any("url", input["url"]).Any("method", input["method"]).Any("path", input["path"]).Any("trace", input["trace"]).Any("session", input["session"]).Any("host", input["host"]).Any("who", input["who"]).Msg("Access denied")
		if checkEntryPoint(req) == Deny {
			return NotFound
		}
		return Authorize
	}

	return Allow
}

func checkEntryPoint(req *http.Request) Action {
	input := Input{
		"url":      req.URL.String(),
		"method":   req.Method,
		"path":     req.URL.Path,
		"trace":    req.Header.Get("Tracing"),
		"session":  req.Header.Get("Session-Id"),
		"host":     core.AppConfig.Host,
	}

	var ok bool
	// Check if entrypoint is valid
	if core.AppConfig.OpaSvc != "" {
		ok = checkPolicyOpaSvc(req, "allowEntrypoint", input)
	} else if core.AppConfig.Policy != "" {
		ok = checkPolicyLocal(req, "allowEntrypoint", input)
	} else {
		ok = true
	}
	if !ok {
		log.Warn().Any("url", input["url"]).Any("method", input["method"]).Any("path", input["path"]).Any("trace", input["trace"]).Any("session", input["session"]).Any("host", input["host"]).Any("who", input["who"]).Msg("Invalid entrypoint")
		return Deny
	}

	log.Info().Any("url", input["url"]).Any("method", input["method"]).Any("path", input["path"]).Any("trace", input["trace"]).Any("session", input["session"]).Any("host", input["host"]).Any("who", input["who"]).Msg("Valid entrypoint")
	return Allow
}

// Policy Enforcement Point to validate access permission
func PolicyHandler(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		// check using OPA rules
		if core.AppConfig.OpaSvc != "" || core.AppConfig.Policy != "" {
			switch checkPolicy(c) {
			case Logout:
				log.Info().Msg("Logout")
				return c.NoContent(http.StatusNotFound)
			case Authorize:
				{
					log.Warn().Msg("Access prohibited by authorization")
					c.Response().Header().Set("WWW-Authenticate", "Basic realm="+core.AppConfig.Realm)
					return c.NoContent(http.StatusUnauthorized)
				}
			case Deny:
				{
					log.Warn().Str("url", c.Request().URL.String()).Msg("Access prohibited by policy")
					return c.NoContent(http.StatusForbidden)
				}
			case NotFound:
				{
					log.Warn().Str("url", c.Request().URL.String()).Msg("Not found")
					return c.NoContent(http.StatusNotFound)
				}
			}
		}
		log.Debug().Msg("Access allowed by policy")
		// next handler if access permitted
		return next(c)
	}
}
